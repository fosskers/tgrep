# tgrep

A tool to locate and store entries in Reddit's large `.log` files. Created for a
coding challenge posted by the Reddit staff in 2011 Feb.

********************
* RUNNING TGREP.PY *
********************

-Run tgrep with the following syntax on the command line:
   python3 tgrep.py 'filename' 'time/time range' > 'output file'
-The order of the filename and times does not matter.

------SERIOUS CODING BUSINESS BELOW - NOT SUITABLE FOR MINORS------

************************
* CRITICAL ASSUMPTIONS *
***********************

Line Length
-This program works off the assumption that the distance between
 two newlines is more than fifteen characters.

File Size
-The binary search running on the file works on the assumption
 that the file is large and that there is at least one entry
 for every second of the 24-hour period. If there isn't,
 the search provides a 'closest value' to what was being looked
 for. However, since the means by which the search
 closes the search field at each iteration is *slightly* dodgy
 (dividing memory addresses, lseeks) some values which are
 actually present in the list can be missed, and another
 (albeit very close) value will be given. In either case,
 the caller method (get_lower_bound()) calls first_instance()
 to clean up the mess by confirming if the position given
 by the bin search was the *first* occurance of that time or not.

*****************
* SPECIAL CASES *
*****************

Argument Cases
-No arguments given.
-Too many arguments given.
-File given but no time indicated.
-With or without a file, the time indicated isn't a valid time.
-Two files given, or two times given (with improper formatting).

Cases While Verifying the Data Set
-The times indicated are the entire set.
-Both times indicated are outside the set.

Data Cases
-The last entry may have the same time as a requested entry
 near the beginning of the file. (24-hour period roll-over)

File Cases
-File is empty.
-File filled with garbage.

********
* BUGS *
********

-There is a problem with the regex in get_time(),
 but the cases it misses are caught by is_valid_time().
 BUG SOURCE: get_time()

-With small file sizes, circular_bin_search() SOMEtimes fails to find
 values that *are* in the list. It finds them most
 of the time. I attribute this to the nature of the file
 searching (as explained in Critical Assumptions).
 BUG SOURCE: circular_bin_search()

*****************
* OPTIMIZATIONS *
*****************

-first_instance() goes back one line at a time to find the earliest
 instance of the given time in the file. For larger files,
 several hundred/thousand jumps are necessary if the instance
 found by the binary search was far away from the first instance.
 OPTIMIZE: Make it jump back and forth multiple lines at a time
           to speed up the search.

***************
* PERFORMANCE *
***************

Best Case
-The user requests times that happen to begin at the
 start of the file. No call to circular_bin_search is
 made, so a lot of effort is saved.

Decent Case
-circular_bin_search happens to yield the first instance
 of the time, so no extra searching is required.

Worst Case
-circular_bin_search happens to yield the last
 instance of the time, meaning the amount of times
 it will have to jump back will be the full number
 of lines to be outputted at the end.

****************************************
* WHAT THE HELL IS CIRCULAR BIN SEARCH *
****************************************

-The method circular_bin_search() performs a hacked
 sort of binary search on a list (file, in this case)
 where the entries are in order, but not linearly.
 That is to say, one end of the list has been cut off
 and moved to the other side.
-Naturally the ideal format of a list for binary search
 would be
    lowest value -> exact middle -> highest value
 but in the case of the test files generated by the Perl
 script, we have something like
    6:00 -> 18:00 -> 6:00
 which, clearly, would send any normal binary search to hell.
-We can imagine that the array/list/file/what-have-you has had
 its two ends tied together, hence the list can be called
 "circular". (I imagine a metal ring with a visible welding
 mark. Each iteration is a rotation of the ring to the left
 and right.)
-The basic logic of the circular bin is as follows:
  1. Find the middle value as normal.
  2. If middle value == target value: Done.
  3. If target value is between the lower bound and middle value,
     or the middle value and the upper bound, then we constrict
     the data set like a normal binary search.
  4. If all these fail, we need to find where the "link" in the
     circle occurs. Fortunately we only need to find out which
     side of the middle value the link occurs on. This is not hard.
  5. Luckily for us, the target value will *always* be on the same
     side as the link if normal binary search logic failed.
-As of this date I haven't yet tested this using a normal array, but
I plan to soon and release my findings, if anybody cares.
